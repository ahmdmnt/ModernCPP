/*
 * _03.1_CLASS_Car.cpp
 *
 *  Created on: Apr 14, 2025
 *      Author: AhmedMontasser
 */

#include "_03.1_CLASS_Car.hpp"

#include <iostream>

/* CLASS.cpp File:-
 * -----------------
 * File where all the Method Definitions shall be available.
 */

/* Static Member Variable:-
 * --------------------------
 * 	- Member with qualifier "static".
 * 	- Members that not part of Object, instead it belong of the Whole Class.
 * 	- One shared copy for the Whole class, for all its objects/instances.
 * 	- CANNOT be initialized inside the class, declaration only and init is outside.
 * 	- Can be initialized by Default Initialization by compiler also.
 */
int Car::totalCarCount {0};

/* Static Member Function:-
 * -------------------------
 * 	- Function in a class qualified with static keyword "static: ONLY required in Declaration".
 * 	- Belong to class not Object.
 * 	- Don't have "this" pointer.
 * 	- Can be invoked from Class name or Object name.
 * 	- Can NOT access non-static members.
 *
 * 	What if this function were NOT static ?
 * 	Here is a limitation, i will not be able to access this function if no object is created
 *  Because this function needs object to be called, but Static Member Function can be called by either class or object name.
 */
void Car::checkCarCount() {			// keyword: static, only added in Function Decalartion.
	std::cout << "-------------------------------------" << std::endl;
	std::cout << "Total Car Count = " << totalCarCount << std::endl;
	std::cout << "-------------------------------------" << std::endl;
}
/******************************************************************************************/

/* Constant Member Function:-
 * ---------------------------
 *	- Member functions that are qualified with "constant" keyword "In both Declaration and Definition".
 *	- Read-only function, can NOT change and modify in any Member variables.
 *		> bcuz members are accessed by "this->", so as if we are trying to dereference "*this" which is constant now >> invalid.
 *	- [IMPORTANT] If I create CONSTANT OBJECT,
 *		> I can only invoke CONSTANT FUNCTION(S) in that Class from that object.
 */
void Car::checkDashboard() const {
	std::cout << "-------------------------------------" << std::endl;
	std::cout << "     Car Name = " << carName << std::endl;
	std::cout << "   Passengers = " << passengers << std::endl;
	std::cout << "         Fuel = " << fuel << std::endl;
	std::cout << "        Speed = " << speed << std::endl;
	std::cout << "Brake Applied = " << brakeApplied << std::endl;
	std::cout << "-------------------------------------" << std::endl;
}
/******************************************************************************************/

/* Constructor:-
 * --------------
 * 	- Invoked automatically during instantiation.
 * 	- Used for Object Initialization.
 * 	- Doesn't return any type.
 * 	- It can accept arguments and can be overloaded.
 *
 * Types of Constructors:
 * ----------------------
 * 	1. Default Constructor:
 * 		- Constructor without any arguments.
 * 		- Automatically generated by compiler.
 * 		- Invoked if there are no any other user-defined constructors.
 *
 * 	2. Parameterized Constructor:
 * 		- Constructor that can have one or more arguments.
 * 		- Used to initialize the object with user-defined values.
 * 		- It is implemented by user, and by default it will block auto generation of default constructor.
 *
 * 	3. Copy Constructor:
 * 		- A constructor that creates a new object as a copy of an existing object.
 * 		- Used in object cloning or when an object is passed by value.
 * 		- If user didn't implement copy constructor, compiler will generate one automatically.
 * 			> Compiler simply copy value from other object. which is not correct in some cases, for e.g. Pointer Members.
 *
 * 	4. Move Constructor:	 MyClass(MyClass &&obj) {}
 * 		- A constructor that transfers ownership of resources from one object to another.
 * 		- Improves performance by avoiding deep copies for temporary objects.
 *
 * 	5. Dynamic Constructor:
 * 		- A constructor that allocates memory dynamically during object creation.
 * 		- Useful for objects requiring dynamic memory allocation.
 *
 * 	6. Delegating Constructor:
 * 		- A constructor that calls another constructor of the same class to reuse initialization logic.
 * 		- Reduces code duplication and streamlines object initialization.
 *
 * 	7. Inheriting Constructor:
 * 		- A feature where a derived (child) class can inherit constructors from its base (parent) class.
 * 		- Simplifies inheritance by avoiding the need to explicitly define constructors in the derived class when they match the base class.
 * ------------------------------------------------------
 *
 * Destructor:-
 * --------------
 * 	- Function invoked automatically when an object is destroyed.
 * 	- Used for release resource when object is destroyed.
 * 	- Class can have one Destructor with no arguments, can NOT be overloaded.
 * 	- If User didn't create a destructor, the compiler will generate one.
 * 	- IMPORTANT TO BE IMPLEMENTED If;
 * 		> Class have any resources that are assigned, needed to be release, for e.g. Heap Resources.
 */
Car::Car() {
	std::cout << "Car() - Default Constructor is invoked!" << std::endl;
	++totalCarCount;
}

Car::Car(int fuelAmmount, int passengerCount) {
	std::cout << "Car() - Parameterized Constructor is invoked!" << std::endl;
	++totalCarCount;
	passengers= passengerCount;
	fuel = fuelAmmount;
}

Car::Car(const Car &refObj) {
	std::cout << "Car() - Copy Constructor is invoked!" << std::endl;
	++totalCarCount;
}

Car::~Car() {	/* Destructor */
	/* [HINT]:  Here we can depend on Normal auto-generated destructor by Compiler,
	 * Because this Class doens't have any resources that are assigned, needed to be release,
	 * for e.g. Heap Resources.
	 */
	std::cout << "~Car() - Destructor is invoked!" << std::endl;
	--totalCarCount;
}
/******************************************************************************************/

/* Normal Class Methods Implementation:-
 * --------------------------------------
 */
void Car::fillFuel(float amount) {
	fuel = amount;
}

void Car::calcAccelerate() {
	this->speed+=10;	// -- USE OF "this" Pointer -- //
	fuel -= 0.5f;
}

void Car::applyBrake() {
	brakeApplied = true;
	speed -= 20;
	if(speed <= 0) {
		speed = 0;
	}
}

void Car::releaseBrake() {
	brakeApplied = false;
}

void Car::addPassenger(int count) {
	passengers += count;
}
/******************************************************************************************/

/* Pointer "this":-
 * -----------------
 * 	- A hidden pointer passed to any member function, for its attributes.
 * 	- Pointer points to the object that is invoking this function.
 * 	- Provided as keyword meaningful only in Member function.
 * 	- It is OPTIONAL to be used.
 * 	- Why to use it?
 * 		- If there is another local variable with same name of Object Attribute.
 * 			as new local variable will hide the Object attribute in that case.
 * 		- I am using Object attributes for a Invoking Object and another passed object (More Readable).
 * 		- If I want to Pass the Invoking Object to a another Member Function, for e.g. FOO(*this).
 *
 * Example for "this Pointer":- */
void Car::comparePassengers(const Car &otherCar) {
	if(this->passengers > otherCar.passengers ) {
		std::cout<< this->carName << " has MORE Passengers...." << std::endl;
	}
	else {
		std::cout<< otherCar.carName << " has MORE Passengers...." << std::endl;
	}
}
/******************************************************************************************/


