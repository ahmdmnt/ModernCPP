/*
 * _34_Templates.cpp
 *
 *  Created on: May 16, 2025
 *      Author: AhmedMontasser
 */


#include <iostream>

/* Module Description:-
 * ---------------------
 * 	1. Intro to Templates.
 * 	2. Function Templates.
 * 	3. Types of Instantiation, except Explicit Specialization
 */

/* Templates:-
 * ------------
 *	- Generalizes SW Components.
 *	- Such Components can be reused in different situations.
 *	- Operate of any kind of data.
 *	- High Performance Algorithms and Classes.
 *	- NO RUN_TIME costs are involved, ONLY Compile time and Code size.
 *
 * Type of Templates:
 * -------------------
 *  - Function Template.
 *  - Class Template.
 *
 *
 * Function Template:
 * -------------------
 * template<typename T_NAME> T_NAME FUNCTION_NAME( ANY/T_NAME ARGS) { ..IMPLEMENTATION.. }
 *
 *	template<typename T>
 *	starting withe keyword template,,, means it is a template function.
 *		<typename T> or <class T> .. this is the placeholder that will receive the changing data type. [diff. in Advanced Template Programming TBD.].
 *
 * If the function template is not invoked:
 * ------------------------------------------
 * then the function is not generated by the compiler.
 * The compiler will generate/instantiate the function for only those types with which it is invoked.
 *
 *
 * Template Arguments Deduction:
 * ------------------------------
 *  - Each function argument is examined, and corresponding type of arg. is deduced.
 *  - Type conversion is not performed during deduction process.
 *  - After Type Deduction, Templates are instantiated subsequently.
 *  - I can Override the Deduction Process, by specify the type explicitly.
 *  	> FUNCTION_NAME<DATA_TYPE>(..ARGS..);
 *
 *
 * Template Instantiation:
 * ------------------------------
 *  - Template function/class act as a blueprint, which is used by compiler
 *     to instantiation corresponding function/class after type deduction.
 *  - Compiler generate the code in Compile time.
 *  - Instantiation Process occurs in:
 *  	- Function Template invoked.	Line #85,#88
 *  	- taking address of function template.	Line #97
 *  	- using explicit instantiation.		Line #  < Next Page
 *  	- creating explicit instantiation.		Line #78
 *  - [[IMPORTANT]]: Template Definition only placed in Header files..
 *     no use of conventional declaration and definition style.
 */

/* ---- Primary Template ---- */
template<typename T>
T maxNumber(T n1, T n2) {
	std::cout<< "Calling typeid()= " << typeid(T).name() << std::endl;
	return n1>n2 ? n1:n2;
}
/* ---- Explicit Instantiation ---- */
template char maxNumber(char n1, char n2);			// Function Deduction of type "char", even if it is not used yet


// Instead of writing multiple function overloading with same code,, it is Better to use template.
//int maxNumber(int n1, int n2) {
//	return n1>n2 ? n1:n2; }
//float maxNumber(float n1, float n2) {
//	return n1>n2 ? n1:n2; }


void _34_FunctionTemplates() {
	/* IN COMPILE TIME:
	 * Compiler will check function arguments,,
	 * and create the corresponding functions from the desired datatypes.
	 */
	auto maxInt {maxNumber(3, 8)};					// Function Deduction of type "int".
	std::cout << "maxInt= " << maxInt << std::endl << std::endl;

	auto maxFloat {maxNumber(3.1f, 8.0f)};			// Another Function Deduction of type "float".
	std::cout << "maxFloat= " << maxFloat << std::endl << std::endl;

	auto maxDouble {maxNumber<int>(3.1, 2.0)};		// Here, Compiler will not deduce from args. and use "double", instead "int" will be used.
	std::cout << "maxDouble= " << maxDouble << std::endl << std::endl;

	//auto maxMix {maxNumber(3, 2.2f)};				   // ERROR: deduced conflicting types for parameter 'T'
	// (CASTING IS NEEDED) >> maxNumber<int>(3, 2.2f)  //or// maxNumber(static_cast<float>(3), 2.2f)

	double (*pFu)(double, double) = maxNumber;		// Here,, Template Function (double) will be instantiated.


}
